---
title: SCSS快速上手
tags: CSS
categories: Web
---

**[Sass](http://sass-lang.com/)**是成熟、稳定、强大的**CSS预处理器**，截止到目前为止已经发展有10年，前当最新release版本为`3.5.1`。而SCSS是**Sass3**版本当中引入的新语法特性，完全兼容CSS3的同时继承了**Sass**强大的动态功能。本文翻译自[Sass Guide](http://sass-lang.com/guide)和[Sass Syntactically Awesome StyleSheets](http://sass-lang.com/documentation/file.SASS_REFERENCE.html)两篇官方文档，讲解了现代化前端开发当中经常使用的SCSS语法特性，便于开发小组的同学快速上手。

![](scss/logo.png)

<!-- more -->

基于Gulp完成前端自动化的年代，出于快速上手以及npm安装方便的考虑，开发团队一直使用[Less](http://lesscss.org)和[gulp-less](https://github.com/stevelacy/gulp-less)作为CSS预处理工具，但是Sass提供了更加丰富的动态语法特征，因此在逐步淘汰基于Gulp的[beaver](https://github.com/uinika/beaver)前端项目脚手架以后，新项目全部基于Webpack的[node-sass](https://github.com/sass/node-sass)和[sass-loader](https://github.com/webpack-contrib/sass-loader)作为预处理工具。Sass和Less的详细比较可以参考[sass-vs-less](https://css-tricks.com/sass-vs-less/)和[Sass与Less比拼](http://cued.xunlei.com/log044)两篇文章，里面对两者的优劣做了非常详实的比较。


## 特性概览


## 编码规则

SASS以**UTF-8**编码输出CSS文件，当且仅当编译后的文件包含**非ASCII**字符时才会输出`@charset`声明，并使用该声明上指定的字符集。

```scss
@charset 'utf-8';
#app {
  background: url('../assets/背景图片.png');
}
```

## CSS扩展

### 嵌套规则

SASS允许CSS规则嵌套使用，父子规则将会呈现**包含选择器**关系，这样可以避免重复使用父级选择器，简化CSS代码结构。

```scss
// SASS
#app {
  width: 100%;
  height: 100%;
  main.login {
    display: flex;
  }
}

// CSS
#app {
  width: 100%;
  height: 100%;
}

#app main.login {
  display: flex;
}
```

### 嵌套属性

CSS许多属性都位于相同的命名空间（*例如`font-family`、`font-size`、`font-weight`都位于`font`命名空间下*），SASS当中只需要编写命名空间一次，后续嵌套的子属性都将会位于该命名空间之下。

```scss
// SCSS
.wrap {
  font: {  // 命令空间后带有冒号:
    family: Arial;
    weight: bold;
    size: 16px;
  }
}

// CSS
.wrap {
  font-family: Arial;
  font-weight: bold;
  font-size: 16px;
}
```

命令空间上可以直接书写**CSS简写属性**，但是日常开发中建议直接书写**CSS简写属性**，尽量保持CSS语法的一致性。

```scss
.wrap {
  font: 20px/24px Arial {
    weight: bold;
  }
}

.wrap {
  font: 20px/24px Arial;
  font-weight: bold;
}
```

### 引用父级选择器&

SASS使用`$`关键字在CSS规则中引用**父级选择器**，例如嵌套使用伪类选择器的场景下。

```scss
// SASS
a {
  font-weight: bold;
  text-decoration: none;
  &:hover {
    color: blue;
    text-decoration: underline;
  }
}

// CSS
a {
  font-weight: bold;
  text-decoration: none;
  a:hover {
    color: blue;
    text-decoration: underline;
  }
}
```

关键字`&`会使用父级选择器**级联替换**全部其出现的位置，

```scss
// SCSS
#main {
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}

// CSS
#main {
  color: black;
}
#main a {
  font-weight: bold;
}
#main a:hover {
  color: red;
}
```

`&`必须出现在组合选择器的开头位置，后面再连接自定义的后缀。

```scss
// SCSS
#app {
  color: gray;
  &-sidebar {
    border: 1px solid;
  }
}

// CSS
#app {
  color: gray;
}
#app-sidebar {
  border: 1px solid;
}
```

> 不存在父级选择器的场景下使用`&`，SASS预处理器会报出错误信息。

### 占位符选择器%

占位符选择器与id或者class选择器的用法类似，只是`#`和`.`被替换成为`%`，占位符选择器必须通过`@extend`指令进行调用。


## 注释

SASS支持标准CSS的多行注释`/* */`和单行注释`// `，其中，多行注释会完整输出到编译后的CSS文件，而单行注释则不会。

```scss
/* it is multiline comments
   it will appear in the CSS output */
body {color: black;}

// it is single-line comment
a {color: green;}
```

编译成为CSS的结果：

```css
/* it is multiline comments
   it will appear in the CSS output */
body {color: black;}

a {color: green;}
```

插值语句`#{$variable}`可以应用在多行注释当中。

```scss
$version: '4.5.3';'
/* This CSS is generated by node-sass version #{$version}. */
```

编译成为CSS的结果：

```css
/* This CSS is generated by node-sass version 4.5.3. */
```

## SassScript

SassScript是SASS提供的语法扩展，允许在任意CSS属性上书写变量、函数和执行计算。SassScript还可以通过`interpolation`插值生成选择器和属性名，这在编写`mixins`时比较有用。

```bash
➜  / sass -i
>> 'hello world'
'hello world'
>> 1px * 3 + 2px
5px
```

### 变量$

SassScript通过`$`关键字声明和使用一个变量。

```scss
$width: 8rem;  // 声明变量

#main {
  width: $width;  // 使用变量
}
```

SassScript变量支持块级作用域，嵌套规则当中声明的变量都是**局部变量**，可以通过`!global`将局部变量声明为**全局变量**。

```scss
#menu {
  $width: 5rem !global;
  width: $width;
}

#sidebar {
  width: $width;
}
```

### 数据类型

SassScript支持6种数据类型，

1. **数值number**：*`1.2`, `13`, `10px`*
2. **颜色color**：*`blue`、`#04a3f9`、`rgba(255, 0, 0, 0.5)`*
3. **布尔值bollean**：*`true`、`false`*
4. **空值null**：*`null`*
5. **字符串string**：有引号或者无引号，*`"menu"`、`'sidebar'`、`navbar`*
6. **数组list**：由空格和逗号分隔，*`1.5em 1em 0 2em, Helvetica, Arial, sans-serif`*
7. **对象map**：*`(key1: value1、key2: value2)`*
8. **函数function**：


### 运算

SassScript所有数据类型都支持`==或!=`逻辑运算，但是每种数据类型还拥有各自的运算方式。

#### 数值运算

数值类型支持常见的数值运算`+`、`-`、`*`、`/`、`%`以及关系运算符`<`、 `>`、`<=`、`>=`，必要时会在不同**绝对**数值单位之间转换。

```scss
p {
  font-size: 1in + 8pt;
}
```

进行除法运算时，需要使用变量但不需要`/`进行除法运算，可以使用`#{}`插值语句包裹变量。

```scss
p {
  font-size: #{$font-size}/#{$line-height};
}
```

#### 颜色运算

颜色值运算是分段进行的，即分别计算**红色**、**绿色**、**蓝色**的值。

```scss
p {
  color: #010203 + #040506;
}

// 进行01+04=05，02+05=07，03+06=09运算后编译为CSS
p {
  color: #050709;
}
```

拥有相同**alpha通道**的颜色值才能直接参与运算，否则会提示错误信息。

```scss
p {
  color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);
}
```

颜色值的**alpha通道**可以使用`opacify`或`transparentize`函数进行计算。

```scss
// SASS
$demo: rgba(255, 0, 0, 0.5);
p {
  color: opacify($demo, 0.3);                     // 增加alpha通道值
  background-color: transparentize($demo, 0.25);  // 减少alpha通道值
}

// CSS
p {
  color: rgba(255, 0, 0, 0.8);
  background-color: rgba(255, 0, 0, 0.25);
}
```

#### 字符串运算 

SassScript使用`+`运算符进行**字符串连接**操作。

```scss
// SCSS
p:before {
  content: 'Foo ' + Bar;         // 有引号字符串 + 无引号字符串 = 有引号字符串
  font-family: sans- + 'serif';  // 无引号字符串 + 有引号字符串 = 无引号字符串
}

// CSS
p:before {
  content: 'Foo Bar';
  font-family: sans-serif;
}
```

有引号的文本字符串同样可以使用插值语句`#{}`添加动态值。

```scss
// SCSS
p:before {
  content: 'I'm #{24 + 8} years old';
}

// CSS
p:before {
  content: 'I'm 32 years old';
}
```

#### 布尔运算

SassScript支持布尔类型的与`&&`、或`||`、非`!`运算。

#### 数组运算

数组不支持任何特定的运算方式，只能通过预置的[list函数](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#Functions)进行操作。

```scss
$color: hsl(120deg, 100%, 50%)
```

#### 函数运算

SassScript预置了多种函数，可以通过普通的CSS语句进行调用。

```scss
// SCSS
p {
  color: hsl(0, 100%, 50%);
}

// CSS
p {
  color: #ff0000;
}
```

Sass函数允许使用**关键词参数**(即*带有键名的参数*)，因此上面例子也可以改写为下面代码。

```scss
p {
  color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
}
```

#### 圆括号运算符

圆括号`()`可以用来影响运算的优先级顺序。

```scss
// SCSS
div {
  width: 2rem + (2rem * 3);
}

// CSS
div {
  width: 8rem;
}
```

#### 插值语法#{}

SassScript通过**插值**（*interpolation*）语法`#{}`在选择器和属性名上使用变量。

```scss
// SCSS
$selector: menu;
$border: border;

div.#{$selector} {
  #{$border}-color: blue;
}

// CSS
div.menu {
  border-color: blue;
}
```

#### SassScript中的&运算符

SassScript中的&运算符指向当前CSS规则的**父选择器列表**。

```scss
.article .paragraph, .division {
  $selector: &;  // $selector = (('.article' '.paragraph'), '.division') 
}
```

当不存在**父选择器列表**的时候，`&`运算符的值为`null`，所以在mixin中可以通过该特性判断*父选择器列表*是否存在。

```scss
@mixin does-parent-exist {
  @if & {
    &:hover {
      color: red;
    }
  }
  @else {
    a {
      color: red;
    }
  }
}
```

#### 变量定义!default

可以在变量后添加`!default`声明，如果变量已被赋值就不会再被重新进行赋值，如果变量未被赋值，则会被赋予新值。

```scss
$content: 'content';
$content: 'defaulted content?' !default;
$new_content: 'new_content' !default;
#main {
  content: $content;
  new-content: $new_content;
}

#main {
  content: 'content';
  new-content: 'new_content';
}
```


## 规则与指令@
Rule / #Directive

Sass支持所有CSS3的`@-Rules`规则以及Sass特有的`#Directive`指令。

### @import / #import

Sass拓展`@import`允许其导入`.scss`或`.sass`文件，导入的文件将合并、编译到相同CSS文件，文件中的变量和mixin都可以在导入位置使用。

但是在下面情况当中，`@import`仅作为普通CSS语句处理，不会导入Sass文件。

1. 文件拓展名为`.css`
2. 文件名以`http://`开头
3. 文件名是`url()`
4. `@import`包含媒体查询

除上述情况外，文件拓展名为`.scss`或`.sass`的情况都会进行预编译处理，即使拓展名缺省依然可以正确进行导入。

```scss
// 下面2种导入方式等效
@import 'base.scss;
@import 'base';
```

Sass允许在同一个`@import`语句内导入多个文件。

```scss
@import 'base', 'reset';
```

`@import`语句内也可以使用`#{}`插值，但是只能用于标准CSS的`@import url("");`导入方式。

```scss
// SCSS
$family: unquote("Droid+Sans");
@import url("http://fonts.googleapis.com/css?family=\#{$family}");

// CSS
@import url("http://fonts.googleapis.com/css?family=Droid+Sans");
```

### @media / #media

Sass中`@media`的用法与CSS相同，但是允许在CSS规则中嵌套使用。编译时`@media`将被编译到文件最外层，包含嵌套的父级选择器。

```scss
// SCSS
.sidebar {
  width: 300px;
  @media screen and (orientation: landscape) {
    width: 500px;
  }
}

// CSS
.sidebar {
  width: 300px;
}

@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px;
  }
}
```

@media的查询条件可以嵌套使用，编译后SASS会自动添加`and`关键字。

```scss
// SCSS
@media screen {
  .sidebar {
    @media (orientation: landscape) {
      width: 500px;
    }
  }
}

// CSS
@media screen and (orientation: landscape) {
  .sidebar {
    width: 500px;
  }
}
```

`@media`的查询条件当中也可以使用SassScript。

```scss
// SCSS
$media: screen;
$feature: -webkit-min-device-pixel-ratio;
$value: 1.5;
@media #{$media} and ($feature: $value) {
  .sidebar {
    width: 500px;
  }
}

// CSS
@media screen and (-webkit-min-device-pixel-ratio: 1.5) {
  .sidebar {
    width: 500px;
  }
}
```

### @extend / #extend

How it Works
Extending Complex Selectors
Multiple Extends
Chaining Extends
Selector Sequences
Merging Selector Sequences
@extend-Only Selectors #placeholders
The !optional Flag
@extend in Directives

### @at-root / #at-root

某些需要放置在文档根元素上的样式，可以就近的放置在其父选择器上，该特性同样可用于行内CSS选择器。

```scss
// SCSS
.parent {
  ...
  @at-root .child { ... }
}

// CSS
.parent { ... }
.child { ... }
```

`@at-root`可以通过**代码块**同时包含多个选择器。

```scss
// SCSS
.parent {
  ...
  @at-root {
    .child1 { ... }
    .child2 { ... }
  }
  .step-child { ... }
}

// CSS
.parent { ... }
.child1 { ... }
.child2 { ... }
.parent .step-child { ... }
```

`@at-root`默认情况下仅仅是排除掉父级选择器，但是实际开发过程中也有可能需要将`@media`之类的指令选择性的过滤、移动到外面，这里可以通过`@at-root (without: ...)`和`@at-root (with: ...)`语法实现该操作。

```scss
// SCSS
@media print {
  .page {
    width: 8in;
    @at-root (without: media) {
      color: red;
    }
  }
}

// CSS
@media print {
  .page {
    width: 8in;
  }
}

.page {
  color: red;
}
```

可以向`@at-root`传递2个特殊值，`rule`表示普通的CSS规则，因此`@at-root (without: rule)`作用类似于没有任何查询条件的`@at-root`；`all`代码全部CSS规则，`@at-root (without: all)`代表样式将会被移动到所有指令和CSS规则的外侧。

There are two special values you can pass to @at-root. "rule" refers to normal CSS rules; @at-root (without: rule) is the same as @at-root with no query. @at-root (without: all) means that the styles should be moved outside of all directives and CSS rules.

If you want to specify which directives or rules to include, rather than listing which ones should be excluded, you can use with instead of without. For example, @at-root (with: rule) will move outside of all directives, but will preserve any CSS rules.

### @debug

### @warn

### @error